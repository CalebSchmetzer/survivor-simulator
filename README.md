# Survivor Simulator (First Version)  
## Project Documentation  

**Disclaimer:**  
This is a fan-made personal project created for entertainment and educational purposes only. It is not affiliated or endoresed by the creators or producers of the television show *Survivor*. It is not intended to be used for any commercial purposes. 

---

## About  
This project is a console-based program that allows users to simulate their own fictional season of the popular reality competition show *Survivor*. The user can follow along as immunity challenges and tribal councils take place until a winner is crowned. 

---

## Key Features 


### Customizable Game Format
- **At the beginning of the program the player will be able to choose their preferred season format:** 
  - Two tribes of 8 players (16 total)  
  - Three tribes of 6 players (18 total)
  - Two tribes of 10 players (20 total)  


### Dynamic Tribe Names 
- Tribe names are generated by combining a random prefix and suffix together from a list of potential options.
- Every season will have a unique combination of tribe names. 
```cpp
std::string tribeNameGeneration() {
    std::string prefixes[]{ "Co","Sa","Se","La","Le","Mo","Tu","Ya","So","Ul" };
    std::string suffixes[]{ "ko","le","co","se","vo","nu","ga","ro","va","to" };

    int prefixSelection = std::rand() % 10;
    int suffixSelection = std::rand() % 10;

    return prefixes[prefixSelection] + suffixes[suffixSelection];
}
```


### Premerge Elimination Cycles 
- One of the tribes will randomly lose the immunity challenge every cycle. 
- The losing tribe will vote a player out of the game.
```cpp
  std::map<std::string, std::vector<std::string>> premergeEliminationCycle(std::map<std::string, std::vector<std::string>>& tribeAssignments) {

	auto losingTribeSelector = tribeAssignments.begin();

	std::advance(losingTribeSelector, std::rand() % tribeAssignments.size());

	std::string selectedTribe = losingTribeSelector->first;
	std::vector<std::string>& tribeMembers = losingTribeSelector->second;

	std::cout << "The " << selectedTribe << " tribe lost the immunity challenge!\n";

	proceedPrompt();

	int index = std::rand() % tribeMembers.size();
	std::string eliminatedPlayer = tribeMembers[index];

	std::cout << eliminatedPlayer << " was voted out by their tribemates!\n";

	tribeMembers.erase(tribeMembers.begin() + index);

	return tribeAssignments;
  }
```


### Merge System 
- When a predetermined number of players remain, a merge will be triggered.
- The number is half of the total number of players (varies based on format selection) + 2.

```cpp
  int calculateMergeNumber(int formatSelection) {

	int mergeNumber{};

	if (formatSelection == 1) {
		mergeNumber = 10;
	}

	else if (formatSelection == 2) {
		mergeNumber = 11;
	}

	else {
		mergeNumber = 12;
	}

	return mergeNumber;
}
```

- All tribes will be disbanded and the remaining contestants will be put into one merged tribe.

```cpp
std::vector<std::string> merge(std::map<std::string, std::vector<std::string>>& tribeAssignments) {

	std::cout << "It's time for the tribes to merge!\n";

	proceedPrompt();

	std::vector<std::string> mergePlayers;

	for (const auto& tribe : tribeAssignments) {
		mergePlayers.insert(mergePlayers.end(), tribe.second.begin(), tribe.second.end());
	}

	tribeAssignments.clear();

	return mergePlayers;
}
```


### Postmerge Elimination Cycles 
- One of the remaining players will win immunity and be safe from being eliminated that cycle. 
- One of the other players will be voted out.
```cpp
std::vector<std::string> postmergeEliminationCycle(std::vector<std::string>& mergedPlayers) {

	int immunityIndex = std::rand() % mergedPlayers.size();

	std::string immunityWinner = mergedPlayers[immunityIndex];

	std::cout << immunityWinner << " has won individual immunity!\n";

	proceedPrompt();

	std::vector<std::string> atRiskPlayers;

	for (const auto& player : mergedPlayers) {
		if (player != immunityWinner) {
			atRiskPlayers.push_back(player);
		}
	}

	std::cout << "Everyone goes to tribal council!\n";

	proceedPrompt();

	int eliminationIndex = std::rand() % atRiskPlayers.size();

	std::string eliminatedPlayer = atRiskPlayers[eliminationIndex];

	std::cout << eliminatedPlayer << " was voted out by their tribemates!\n";

	for (auto i = mergedPlayers.begin(); i != mergedPlayers.end(); ++i) {
		if (*i == eliminatedPlayer) {
			mergedPlayers.erase(i);
			break;
		}
	}

	return mergedPlayers;
}
```
### Winner Determination 
- Once only two players remain, the winner is randomly selected between them. 
```cpp
std::string determineWinner(std::vector<std::string> mergedPlayers) {
	int winnerIndex = std::rand() % mergedPlayers.size();

	std::cout << "The final two are: " << mergedPlayers[0] << " and " << mergedPlayers[1] << "!\n";

	proceedPrompt();

	std::string winner = mergedPlayers[winnerIndex];

	return winner;
}
```
---

## Future Update Ideas 

1. **Add twists and advantages**  
   - Hidden Immunity Idols
   - Tribe Swaps
   - Double Eliminations
   - Exile Island
   - Redemption Island  

2. **Allow the user to input their own contestant and tribe names**  
  
3. **Add Season Presets the user can choose from**  
   - Heroes vs Villains
   - Fans vs Favorites
   - Blood vs Water
     
4. **Add more formats and customization**
   - Final three instead of final two
   - Four tribes with 16 or 20 total players
   - Customizable merge number

 5. **Alliances and Voting Logic**
    - System for contestants to make alliances with each other.
    - System for having each contestant cast votes at tribal council based off said alliances.   
